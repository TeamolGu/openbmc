diff --git a/console-client.c b/console-client.c
index 1f85176..421d672 100644
--- a/console-client.c
+++ b/console-client.c
@@ -30,6 +30,16 @@
 
 #include "console-server.h"
 
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#define FAIL -1
+#define OK   0
+
+int speed_arr[] = {B115200,B57600,B38400,B19200,B9600,B4800,B2400,B1200,B600,B300,B110};
+int name_arr[]  = { 115200, 57600, 38400, 19200, 9600, 4800, 2400, 1200, 600, 300, 110};
+
 #define EXIT_ESCAPE 2
 
 enum process_rc {
@@ -132,6 +142,36 @@ static enum process_rc process_str_tty(
 	return prc;
 }
 
+/* filter the ASCII code 0-9,11-31 from the array input & modify the len after filter action
+ * author: TEAMOL
+ * mail: 28105285@qq.com
+ * date: 20221121
+ * */
+static int sort_array(uint8_t *p, int len)
+{
+	int i, j;
+	int t_len = 0;
+	int fd, rc = 0;
+	char *filename = "/tmp/console.bin";
+
+	fd = open(filename, O_RDWR|O_APPEND|O_CREAT, S_IWUSR);
+        rc = write(fd, p, len);
+	rc++;
+	close(fd);
+
+        for (i = 0; i < len; i++) {
+                //if ((p[i] >= 0 && p[i] <= 9) || (p[i] >= 11 && p[i] <= 31)) { /* filter of ASCII CODES */
+                if ((p[i] == 0) ) {
+	                fprintf(stderr, "===p[%d]=%d\r\n", i, p[i]);
+			t_len++;
+			for (j = i; j <= len - i; j++) {
+			        p[j] = p[j + 1];
+			}
+		}
+	}
+        return (len - t_len);
+}
+
 static enum process_rc process_tty(struct console_client *client)
 {
 	uint8_t buf[4096];
@@ -143,6 +183,9 @@ static enum process_rc process_tty(struct console_client *client)
 	if (len == 0)
 		return PROCESS_EXIT;
 
+	fprintf(stderr, "before len=%d\n", len);
+	len = sort_array(buf, len);
+	fprintf(stderr, "after len=%d\n", len);
 	switch (client->esc_type)
 	{
 	case ESC_TYPE_SSH:
@@ -170,6 +213,7 @@ static int process_console(struct console_client *client)
 		return PROCESS_EXIT;
 	}
 
+	len = sort_array(buf, len);
 	rc = write_buf_to_fd(client->fd_out, buf, len);
 	return rc ? PROCESS_ERR : PROCESS_OK;
 }
@@ -250,6 +294,130 @@ static void client_fini(struct console_client *client)
 	close(client->console_sd);
 }
 
+/* set baud rate */
+void set_speed(int fd, int speed)
+{
+    int i;
+    int status;
+    struct termios options;
+
+    tcgetattr(fd, &options);
+    //options.c_iflag &= ~ (INLCR | ICRNL | IGNCR);
+    options.c_oflag &= ~(ONLCR | OCRNL);
+    //options.c_iflag &= ~(IXON);
+    options.c_iflag &= ~(BRKINT | ICRNL | ISTRIP | IXON);
+
+    for( i= 0; i < sizeof(speed_arr) / sizeof(int); i++)
+    {
+        if(speed == name_arr[i])
+        {
+            tcflush(fd, TCIOFLUSH);/*empty input cache*/
+
+            cfsetispeed(&options, speed_arr[i]);
+            cfsetospeed(&options, speed_arr[i]);
+
+            status = tcsetattr(fd, TCSANOW, &options);
+            if(status != 0)
+                   perror("tcsetattr fd");
+
+            return;
+        }
+        tcflush(fd,TCIOFLUSH);/*empty input cache*/
+    }
+}
+
+/**
+ * *@brief 设置串口数据位，停止位和效验位
+ * *@param fd 类型 int 打开的串口文件描述符
+ * *@param databits 类型 int 数据位 取值 为 7 或者8
+ * *@param stopbits 类型 int 停止位 取值为 1 或者2
+ * *@param parity 类型 int 效验类型 取值为N,E,O,S
+ * */
+int set_parity(int fd,int databits,int stopbits,int parity)
+{
+    struct termios options;
+    if ( tcgetattr( fd,&options) != 0)
+    {
+        perror("SetupSerial 1");
+        return(FAIL);
+    }
+    options.c_cflag &= ~CSIZE;
+    options.c_lflag  &= ~(ICANON | ECHO | ECHOE | ISIG);  /*Input*/
+    options.c_oflag  &= ~OPOST;   /*Output*/
+
+    switch (databits) /*set datebits*/
+    {
+        case 7:
+            options.c_cflag |= CS7;
+            break;
+        case 8:
+            options.c_cflag |= CS8;
+            break;
+        default:
+            fprintf(stderr,"Unsupported data size\n");
+            return (FAIL);
+    }
+
+    switch (parity)
+    {
+        case 'n':
+        case 'N':
+            options.c_cflag &= ~PARENB; /* Clear parity enable */
+            options.c_iflag &= ~INPCK; /* Enable parity checking */
+            break;
+        case 'o':
+        case 'O':
+            options.c_cflag |= (PARODD | PARENB); /* 设置为奇效验*/
+            options.c_iflag |= INPCK; /* Disnable parity checking */
+            break;
+        case 'e':
+        case 'E':
+            options.c_cflag |= PARENB; /* Enable parity */
+            options.c_cflag &= ~PARODD; /* 转换为偶效验*/
+            options.c_iflag |= INPCK; /* Disnable parity checking */
+            break;
+        case 'S':
+        case 's': /*as no parity*/
+            options.c_cflag &= ~PARENB;
+            options.c_cflag &= ~CSTOPB;
+            break;
+        default:
+            fprintf(stderr,"Unsupported parity\n");
+            return (FAIL);
+    }
+    /*set stopbits */
+    switch (stopbits)
+    {
+        case 1:
+            options.c_cflag &= ~CSTOPB;
+            break;
+        case 2:
+            options.c_cflag |= CSTOPB;
+            break;
+        default:
+            fprintf(stderr,"Unsupported stop bits\n");
+            return (FAIL);
+    }
+    /* Set input parity options */
+    if (parity != 'n')
+        options.c_iflag |= INPCK;
+
+    //options.c_cc[VTIME] = 0; // 15 seconds
+    //options.c_cc[VMIN] = 0;
+    options.c_cc[VTIME] = 128;
+    options.c_cc[VMIN] = 1;
+
+    tcflush(fd,TCIFLUSH); /* Update the optionsions and do it NOW */
+
+    if (tcsetattr(fd,TCSANOW,&options) != 0)
+    {
+        perror("tcsetattr");
+        return FAIL;
+    }
+    return (OK);
+}
+
+
 int main(int argc, char *argv[])
 {
 	struct console_client _client, *client;
@@ -259,14 +427,16 @@ int main(int argc, char *argv[])
 	struct config *config = NULL;
 	const char *socket_id = NULL;
 	const uint8_t *esc = NULL;
-	int rc;
+	int rc, flag_com = 0, fd = 0;
+	const char *com = NULL;
 
 	client = &_client;
 	memset(client, 0, sizeof(*client));
 	client->esc_type = ESC_TYPE_SSH;
 
+	fprintf(stderr, "===obmc-console-client===V20221116\n");
 	for (;;) {
-		rc = getopt(argc, argv, "c:e:i:");
+		rc = getopt(argc, argv, "c:e:i:p:");
 		if (rc == -1)
 			break;
 
@@ -292,9 +462,27 @@ int main(int argc, char *argv[])
 			}
 			socket_id = optarg;
 			break;
+		case 'p':
+			if (optarg[0] == '\0') {
+				fprintf(stderr, "COM device str cannot be empty\n");
+				return EXIT_FAILURE;
+			}
+			flag_com = 1;
+			com = optarg;
+		        fprintf(stderr, "start open %s !\n", com);
+			fd = open(com, O_RDWR, S_IWUSR);
+			set_parity(fd, 8, 1, 'N');
+			set_speed(fd, 115200);
+		        fprintf(stderr, "end open %s ,fd=%d!\n", com, fd);
+			if (fd == -1) {
+				fprintf(stderr, "open %s failed!\n", com);
+                                return EXIT_FAILURE;
+			}
+			break;
 		default:
 			fprintf(stderr,
 				"Usage: %s "
+				"[-p <COM1-5,ttyS0-4>]"
 				"[-e <escape sequence>]"
 				"[-i <socket ID>]"
 				"[-c <config>]\n",
@@ -331,10 +519,19 @@ int main(int argc, char *argv[])
 		goto out_client_fini;
 
 	for (;;) {
-		pollfds[0].fd = client->fd_in;
-		pollfds[0].events = POLLIN;
-		pollfds[1].fd = client->console_sd;
-		pollfds[1].events = POLLIN;
+	        if (flag_com == 0) {
+	                pollfds[0].fd = client->fd_in;
+	                pollfds[0].events = POLLIN;
+	                pollfds[1].fd = client->console_sd;
+	                pollfds[1].events = POLLIN;
+	        }
+                else {
+                        pollfds[0].fd = client->fd_in;
+                        client->fd_out = fd;
+                        pollfds[0].events = POLLIN;
+                        pollfds[1].fd = client->console_sd;
+                        pollfds[1].events = POLLIN;
+                }
 
 		rc = poll(pollfds, 2, -1);
 		if (rc < 0) {
